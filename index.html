<html>
    <title> INFO5100 Final Proj</title>
    <head>
    	<script src="https://d3js.org/d3.v4.min.js"></script>
    </head>

    <body>
        <div id = "userInputs">
			<svg id = "p1" width = "400" height = "400"></svg>
			<svg id = "animation" width = "400" height = "600"></svg>
        </div>

 	<script type="text/javascript">
         var svg1 = d3.select("#p1");
         //random
         var randomIndex = function(total) {
		  return Math.floor(Math.random()*total);
		 }
		  var nodes1 = d3.range(30).map(function(d) {
		  	if (d<10) return {
		  		"radius":8,
		  		"group":0
		  	}
		  	else if(d<20) return {
		  		"radius":8,
		  		"group":1
		  	}
		 	return {
		 		"radius":8,
		 		"group":2};
		 });

		var color = d3.scaleOrdinal(d3.schemeCategory10);

		 rix = randomIndex(20);
		 var width = 300;
		 var height = 300;
		 var xCenter = [10,100,200]
		 var yCenter = [10,100,200]
		 var simulation1 = d3.forceSimulation(nodes1)
		 // .force('charge', d3.forceManyBody())
		 .force("center", d3.forceCenter(width / 2, height / 2))
		 .force('x', d3.forceX().x(function(d) {
  			return xCenter[d.group];
			}))
		 .force('y', d3.forceY().y(function(d) {
			  return yCenter[d.group];
			}))
		 .force('collision', d3.forceCollide().radius(d => d.radius + d.radius*2*Math.random()))
		 .on('tick', ticked1);

		 var circles = svg1.selectAll('circle')
		 .data(nodes1).enter()
		 .append('circle')
		 .attr('r', d => d.radius)
		 .attr('fill', d => color(d.group));

		 function ticked1(){
		  circles.attr("transform", function (d) {
		         var upperx = Math.min(width-d.radius, d.x);
		         d.x = Math.max(0+d.radius, upperx);
		         var uppery = Math.min(height-d.radius, d.y);
		         d.y = Math.max(0+d.radius, uppery);
		         return "translate(" + d.x + "," + d.y + ")";
		        });
		 }
		 console.log(circles._groups[0]);
		circles._groups[0].forEach(function(d){
			data=d.__data__
			console.log(data)
			if(data.group == 1){
				var points = [
					[data.x,data.y],
					[(300+data.x)/2, data.y+Math.random() * 20],
					[300,data.y]
					]
				}
			else if(data.group == 2){
					var points = [
					[data.x,data.y],
					[(300+data.x)/2, data.y+Math.random() * 20],
					[300,data.y]
					]
				}
			else{
					var points = [
					[data.x,data.y],
					[(300+data.x)/2, data.y+Math.random() * 20],
					[300,data.y]
					]
				}

			var line = d3.line()
		       .curve(d3.curveCardinal.tension(.0));


		 //     var points = [
			//    	[0, 80],
			//    	[100, 100],
			//    	[200, 30],
			// ];

			svg1.append("path")
		   .datum(points)
		   .attr("d", line)
		   .style("stroke", "green")
		   .style("stroke-width", "4")
		   .style("fill", "transparent");




			// var path = svg1.append("path")
		 //    .datum(points)
		 //    .attr("d", line)
			})
		

	</script>


	<script>
		var fake_start = 100000;
		var fake_end = {"stock":[2000, 20000, 20000], "housing": 2000, "bound": 2000}
		var fake_obj = {"stock":[0.1, 0.1, 0.3, 0.15], "housing": 0.2, "bound": 0.15};
		var color_scheme = ["black", "grey", "pink", "green", "yellow", "red", "blue"];

	    draw_money("animation", fake_amount, fake_end, fake_obj, color_scheme);

		function draw_money(id, start_amount, end_amount, ratio_obj, colors) {
			var svg = d3.select("#" + id);
			var width = 400;
			var height = 600;
			var padding = 30;
			
			// generate center names based on input object
			var centers = [];
			if (ratio_obj.housing > 0) {
				centers.push("housing");
			}
			else if (ratio_obj.bound > 0) {
				centers.push("bound");
			}
			else if (ratio_obj.stock.length >0) {
				for (var i = 0; i< ratio_obj.stock.length; i++) {
					centers.push("stock" + i);
				}
			}
			console.log(centers)

			// generate the coordinates for each activity's centroids
			var centroids = {};
			var origin_position = { x:(width-padding) * 0.33, y: height/2, color: colors[0]};
			// assign positions to different invest options
    		centers.forEach(function(center, i) {
				var theta = 2 * Math.PI/party_names.length;
				centroids[party] = { x: (width-padding) * 0.67,
									y: (height - padding)/centers.length*(i+1),
									color: colors[i+1] };
			});

			// generate data objs

			

			
			
		}
		
		

	</script>


    </body>
</html>